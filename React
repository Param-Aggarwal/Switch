React 



React is library to manage SPA. 
One Way data binding. 

In Strict Mode, React will call some of your functions twice instead of once. Only component, initializer, and updater functions need to be pure. Event handlers don‚Äôt need to be pure, so React will never call your event handlers twice.



React Rendering ‚Äî> 
- React makes copy of real DOM called VIRTUAL DOM, makes changes to that first as it is less expensive and fast, identifies difference with respect to Real DOM, and then applies only the reqd changes to REAL DOM. 
- By default, Reacts performs Client Side Rendering only. SSR can also be implemented fro particular case but not as easy as other library like Next.js. (in backend code, call for app component has to be made, then on frontend, that rendered server side component has to be hydrated with js on frontend)
- In React, functions and variables declared inside a component body are re-created on every render. This includes:
    * Arrow functions (const handleClick = () => {})
    * Objects (const obj = {})
- This is why hooks like useCallback and useMemo exist: to preserve reference identity between renders when needed.

Client Side Rendering ‚Äî> 
- All the bundled code(in form of HTML, CSS, JS files) is sent to client, and rendering of the web components happen in the client side only. Painting of the Dom happens at the client side only. 
- Processing for creation of Html elements from js happens at the client side, whenever the call is made for the website. 

Server Side Rendering ‚Äî>  
- The bundled code (HTML, CSS) is processed on the server side beforehand and stored in cache/DNS and is sent to the client as is. This reduces initial loading time on the client and increases UX. 
- Here, React app is also sent to the client(in form of HTML, CSS, JS) in the background. 
- And after the initial rendering of the pre-loaded HTML/CSS, whole react component renders again in the client, and JS is hydrated to the elements in runtime. 
- This re-rendering does not change any pre-loaded HTML elements(because the code is same before and after). Thus, the JS part is attached to the elements at the runtime so smoothly, that the client does not feel any change in UI. And hence does not degrade UX. 
- Note: Whole React APP is rendered again on the client but it feels like that only JS is attached at the client side because the initial loaded HTML, CSS is same afterwards also. 

Hydration Failure ‚Äî> 
- Sometimes, there occurs a difference between pre-loaded HTML, CSS components and re-rendered HTML, CSS, JS components. 
- This may occur due to some change in HTML while attaching JS. This may result in error in the UI. This is called Hydration Failure. 

Static Site Generation ‚Äî> 
- Here, During the bundling of the code, whole component is pre-rendered along with HTML, CSS, JS and stored as cache/DNS. Here, website is compiled and run at the build time only. 
- And the static site is served to the client with pre-loaded JS. All the functionality works fine. And no re-rendering of the website takes place in the background. 
- This increase the performance significantly as server/client does not need to render every page dynamically for every request. 

Incremental Site Generation ‚Äî> 
-  Whenever any new data is added, then that data is added to the static site in the incremental fashion so as to not loose the advantage of SSG. 
- Incremental static site generation, aka incremental static regeneration (ISR), is a pattern added to static site generation that allows updating of existing pages and adding new ones, by pre-rendering a subset of pages in the background even while receiving new requests for pages.
- Flow is something like: 
    * During the initial site build, Next.js (often used with ISR) pre-renders static pages using¬†getStaticProps.¬†This means HTML is generated for these pages based on the available data at build time.¬†
    * You configure a¬†revalidate¬†time for each page.¬†This tells Next.js how often to check for updates.¬†For example,¬†revalidate: 60¬†means it checks for updates every 60 seconds.¬†
    * When a user visits a page after its revalidation period has passed, the page will still serve the cached, static version initially.¬†
    * Background Regeneration: Next.js then triggers a regeneration of that page in the background.¬†It fetches the latest data and rebuilds the HTML.¬†
    * Cache Update: Once the page is successfully regenerated, the cache is updated with the new version.¬†
    * Subsequent Requests: Subsequent requests to that page will then serve the updated, cached version, ensuring that users see the latest content.¬†
    * On-Demand Revalidation: If you need to update content immediately, you can use on-demand revalidation to trigger a page regeneration outside the scheduled revalidation time.¬†
Hot Module Reloading ‚Äî>
- Fdvgv




URL based Routing ‚Äî> 

Components ‚Äî> 
- Lifecycle of Component ‚Äî> Mounting, Updating, Unmounting 
Controlled Components ‚Äî> 
- We change components based on the change in state which is controlling that component
Pure and Impure Components ‚Äî> 
Strict Component ‚Äî> 
- wrapped around App Component to help us be safer and prevent errors. 
Portal Component ‚Äî> 
- used when Particular component is to be loaded at specific place under specific component every time. 
Suspense component‚Äî> 
- used as fallback when data takes time to load. 


JSX ‚Äî> JS with XML , dynamic rendering possible with JSX opposite to HTML Static rendering. 
Props ‚Äî> 
    - Used to pass properties onto child component. 
    - It is an Object. 
    - Can pass anything inside props, be it variables, functions, components(child components) etc. 
    - Has problem of Prop Drilling.  
State ‚Äî> to manage data 


Hooks ‚Äî> 
- Hooks are functions which allows us to hook and manage states. 
- Hooks use the concept of closure to persist the state data across re-renders. 
- Lets us add state and other features to our functional components without using class based components. 
- GPT Link for Hooks: https://chatgpt.com/c/683c5e61-ccdc-8001-b424-70e94cc4955b (In Depth analysis)
- Link for below video: https://www.youtube.com/watch?v=LOH1l-MP_9k (Summarising all the hooks with their functionalities)
- Ôøº

State Hooks ‚Äî> hooks like useState rely on closures + React‚Äôs internal hook array to preserve and reconnect state values between renders ‚Äî that‚Äôs the essence of ‚Äústateful functional components‚Äù.
- useState ‚Äî> to manage simple state management
* If you pass a function to useState, React will only call it during initialization. Eg:   const [todos, setTodos] = useState(createInitialTodos()); The above line calls createInitialTodos function on every render. But it is not required as this required only on the initial render. So, instead of above, we can call:          const [todos, setTodos] = useState(createInitialTodos);This ensures that the fn is called only during the initial render and not again. 
* Ceveats ‚Äî >
    * React may call your initializers,updaters twice in development to verify that they are pure. 
    * INITIALISER, UPDATER AND COMPONENTS must be pure functions. 
    * Compares the state with Object.is comparison. 
    * BATCHES STATE UPDATES (It updates the screen after all the event handlers have run and have called their set functions). In we want to update state earlier, we can use flushSync() function and pass the setState function inside that. It causes state update synchronously bypassing the above behaviour. 
    * Adding state in useEffect Dependencies does not cause Re-render. 
    * When you update nested state, you need to create a copy of the object you‚Äôre updating, as well as any objects ‚Äúcontaining‚Äù it on the way upwards
    * 
- useReducer ‚Äî> to handle complex or multiple dependent states with a single reducer function.
    * Helpful as it makes changes to all the related states in a single hook. 
    * Takes input ‚Äî>  useReducer hook takes 2 inputs: Reducer function and initial states object
    * Outputs ‚Äî> state object + dispatch function which changes the state based on actions. This function (dispatch) is called whenever this hook is triggered. 

Effect Hooks ‚Äî> 
Used for dealing with external systems or doing things cannot be done by any other hook
- useEffect ‚Äî> 
    * Is asynchronous in nature
    * used to perform side effects 
    * Generally used for following two types of Side effects: 
        1. Event based ‚Äî> click, submit, etc  ‚Äî> But this should be handled by event Listeners itself and not useEffect
        2. Render Based ‚Äî> fetch data from external system ‚Äî> this should be handled by React Query or Next.js Iibrary. 
    * SHOULD NOT BE USED OFTEN. 
    * Actual USE CASE of useEffect is to sync React components with Browser APIs. 
    * For eg: when we want to sync video element of html with some variables. i.e. handle DOM elements with variables/states.
    * For eg: if isPlaying == true, then instruct the video element to play, otherwise stop. 
- useLayoutEffect ‚Äî> 
    * stricter version of use Effect. 
    * Runs before rendering the page for the first time. 
    * Is synchronous. Helpful in getting details from browser at runtime and then using them to load data. 
    * Use Case: find out client layout measurement and setting them in state even before rendering. 
- useInsertionEffect ‚Äî> 
    * Runs before the above two. Even before rendering the ui. I
    * s synchronous. To add styles to a particular js elements. 
    - Ôøº

Context Hooks ‚Äî> 
- useContext ‚Äî> Instead of prop Drilling, we use this hook to provide global context to our parent component and then can use it anywhere inside the child component even if it is 3-4-5 levels deep. 
    * How to implement ‚Äî> 
        * Create context variable or object with the context values. (Can be defined in separate file named Context.js)
        * Wrap your parent component with Context.provider component. 
        * Pass value of context inside ContextProvider component as props. 
        * Use that value in child component with useContext Hook and the above made context variable as input. 
    * Directory Structure can be ‚Äî> 
        * Ôøº
    * All components using useContext re-render when context value changes
    * Ca be used in combination with useState or useReducer hook. 
    * Use Case ‚Äî> helps in enabling features like: (Basically global setting that do not change much)
        * Theme Switching
        * Authentication Context
        * Language Settings etc. 

Ref hooks ‚Äî> 
- useRef ‚Äî> 
    * It is similar to useState but keeps the state data across multiple re-renders. 
    * And also does not re render a page when state changes. 
    * It takes input the initial value of state similar to useState hook. 
    * It Outputs only the state data object, not a function (like SetData). because data is mutable itself. 
    * It has .current property which is used to change the values of data. 
    * Also have ref attribute to set value of data. Generally used to store DOM elements. 
    * Perfect for storing values like DOM elements, timers, or any mutable object that doesn‚Äôt need to trigger UI changes.
- useImperativeHandle ‚Äî> 
    * Similar to ref hook but used when we want to pass the ref to child component. 
    * Needs ForwardRef function. 
    * Not used much
    * Implementation: 
        * make the ref
        * pass that as a prop to child component
        * wrap the child function inside forwardRef() function
Performance Hooks ‚Äî> 
- useMemo ‚Äî> implements memoisation to increase speed and avoid unnecessary calculations. 
    * It is used whenever we want to store value when something changes, For Eg: if numbers array change, the only calculate sum. 
    * i.e. Runs during a re-render. But does not cause a re-render itself. 
    * It always returns an output with some value. 
    * So the value of that sum can be assigned to any variable which may or may not be managed by any other hook
    * Conclusion ‚Äî> Whenever the component re-renders (due to any state/prop change), useMemo() checks if its dependencies changed.
        * If yes ‚Üí it recomputes the value.
        * If no ‚Üí it returns the cached value from the last render.
- useCallback ‚Äî> similar to useMemo but for functions instead of variables or objects. It Caches functions between renders. 
    - Does not trigger re-render. Runs during re-render only if dependency is changed. 
    - It basically maintains the identity of function at the time of re-rendering if the dependency is not changed in that re-rendering. 
    - Use it when function identity really matters ‚Äî especially with:
        * React.memo
        * custom hooks
        * props optimisation
        * On useEffect Dependencies
    - Don‚Äôt ‚Äî> If you're not passing the function as a prop or not depending on it in useEffect/useMemo, you probably don‚Äôt need useCallback. 

Transition Hooks ‚Äî> 
- useTransition ‚Äî> used when we need to run non-urgent state updates in background with low priority   so that urgent ones perform first. It Keeps UI Responsive while doing heavy updates in background. 
    * It does not make our code faster or it does not cancel the execution of the function. 
    * It just cancels the execution for previous state change 1 if a new state change 2 is received which has more priority. 
    * So the flow is like: 
        * change1 initiated ‚Äî> 
        * handleChange1() is called with low priority set ‚Äî> 
        * change2 initiated before completion of handleChange1() ‚Äî> 
        * then handleChange2() is started and handleChange1() is abandoned. 
    * Helps in laggy UI scenarios 
    * Use Cases ‚Äî> 
        * Large list filtering ‚Äî> Don't freeze input while filtering 
        * Tab switching in dashboards ‚Äî> Load new tab content in background
        * Search-as-you-type ‚Äî> Let user type freely while searching
        * Form suggestions/autocomplete ‚Äî> Defer API-heavy suggestions
        * Rendering charts/graphs ‚Äî> Render Ul-heavy components non-urgently
- useDefferedValue ‚Äî> 
    * instead of running in background, it defers the execution of the function upto some time(adaptive time delay by React only) and runs back the fn when it is free to do so. 
    * So the flow is like: 
        * change1 initiated ‚Äî> 
        * handleChange1() is not called but deffered for some time‚Äî> 
        * change2 initiated before starting of handleChange1() ‚Äî> 
        * then handleChange2() is started and handleChange1() is dropped. 
    * Also helps in laggy UI scenarios 
    * Can use useDeferredValue with React.memo() or useMemo() to optimise rendering of components that use the deferred value.
    * It Doesn't delay the state itself ‚Äî> Only the value passed to the next component is delayed
    * Use Cases ‚Äî> 
        * Filtering/search ‚Äî>Don‚Äôt block input while showing results
        * Large lists ‚Äî> Avoid re-rendering whole list too often
        * Dependent drop-downs ‚Äî> Prevent UI freezing when one state triggers heavy work

- üß† Final Difference Recap:
    * useTransition‚Üí Runs the expensive update in the background with low priority‚Üí If a new high-priority update comes (e.g., user types again),‚Üí The previous low-priority update may be abandoned, and the new one starts
    * useDeferredValue‚Üí Delays the propagation of the input (query) to the expensive function‚Üí If input changes quickly again, it may skip earlier values‚Üí Only latest deferred value is eventually used‚Üí The expensive function is never called for intermediate values
* 
Extra hooks ‚Äî> 
- useId ‚Äî> Think of useId() as a layout helper, not a data identifier.
    * for generating random id‚Äôs for html attributes labelling. 
    * Can‚Äôt be used for object id‚Äôs when listing elements. \
* Not used in below scenarios: 
    * If you're styling with CSS using IDs (not recommended anyway).
    * If you're building only one instance of the form and are okay hardcoding static IDs.
    * If you don‚Äôt need label-input linking (e.g., placeholder-based UI).
- useDebugValue ‚Äî> 
    * only used when using react debug tools in order for debugging. 


React 19 Hooks ‚Äî> 
- Don‚Äôt need to use useMemo and useCallback hooks as compiler itself does the optimisation. 
- Don‚Äôt need ForwardRef at all. React compiler does this automatically. 
- use ‚Äî> 
    * Lets u load resources asynchronously
    * Can resolve promises as well as read contexts. 
    * Replaces useEffect for rendering and useContext for reading context completely.
    * Instead of useEffect, we make fetch call inside use() hook with no dependency array. Also, provides functionality of Suspense component for acting as a fallback while loading the data in the background. Just wrap the component with Suspense component with fallback attribute and inside that your jsx. 
    * Instead of useContext(), just use use() completely. basically a name change, u can assume. 
    * Directives ‚Äî> 
        * helps specify where to run the code (client or server)
        * implementation: ‚Äúuse client‚Äù or ‚Äúuse server‚Äù at the top of function/component file. 
- useOptimisitic() ‚Äî> 
- useID() ‚Äî> Think of useId() as a layout helper, not a data identifier.















React Concepts ‚Äî> 
Lazy initialisation:  
- Lazy initialization via callback in useState done to prevent heavy computational calls at every render. 
- For heavy computational functions, we call them in callback function rather than calling the function directly, This is because in callback fashion, only the reference is passed, not the whole function. So the function does not get called immediately. Instead only called once. 
- If the initializer is a function, call it only during the first render (mount) to compute the initial state.
- After that, React stores the returned value and never calls that initializer again, even if the component re-renders.
- This is React-specific and specific to useState‚Äôs implementation.

- Hooks use the concept of closure to persist the state data across re-renders. 

Batching:
- When React sees multiple changes to the state, then it batches those updates and optimises inherently to reduce the renders of the component and hence increase the performance. 
- Batching is process of optimising the state updates in a single renders. 
- Note: this is done by React 18+ only and not in lower versions. And React batches sync and async tasks both.
Conside the example: function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1);
  };

  console.log("Render:", count);
  return <button onClick={handleClick}>Count: {count}</button>;
}Here, set count will be called twice but render of the Counter component will be only once as react internally sees that same change is being done 2 times, so it optimises. 
React Version	setCount called	Renders	Final count
React 17	Twice	Twice	1
React 18+	Twice	Once (batched)	1
setCount(c => c + 1);
await fetch('/api/data');   // asynchronous boundary
setCount(c => c + 1); 													‚Äî> dens not cause batching as async task executes between the state updates. 

setTimeout(() => setCount(c => c + 1), 0);
setTimeout(() => setCount(c => c + 2), 0);								‚Äî> Still breaks batching as both have different tasks in queue and hence treated different. If they were is a single promise or setTimeout, then batting would have worked. 

Props: 
- Can use props to pass data to components. 
- Props can be used to design reusable UI components. (Via composition)
- Instead of relying on inheritance, I create flexible child components that accept dynamic content (via children or props) ‚Äî so the parent can decide what to render inside them. This follows React‚Äôs composition model, allowing the same component to adapt to multiple use cases.‚Äù
- Eg: 
function Child({ children }) {
  return <div className="p-4 border rounded-lg">{children}</div>;
}

function Parent() {
  return (
    <Child>
      <h2>Param Aggarwal</h2>
      <p>Frontend Engineer</p>
    </Child>
  );
}
Here, Child is a reusable component which applies the same css and formatting to all the components with whatever is rendered inside it. 
- By default ,React re-renders all children when parent re-renders. 
- When Prop changes, all consumers of props re-renders. Even when static prop is passed onto children, if the parent re-renders, child will also re-render no matter the prop is changes or not !! 
- This can be removed or reduced by using useMemo hook which shallow copies the value of props and if found same, then does not re-render the child component. Foor more info, Read Hooks ‚Äî> useMemo

Context: 
- gnfg
- Fvjnsdfvf
- Fjnwem
- Jngmw
- 
In setState, prev is React‚Äôs built-in way to always give you the latest state, so you can safely build the next state without worrying about stale variables. Using the functional updater is considered best practice whenever the new state depends on the old state.

Preventing of re-renders in contexts, props, states etc. by React.memo(), useMemo(), useCallback() given below: 
Concept	Purpose	When to Use
React.memo	Skip re-render if props same	Static child props
useMemo	Cache heavy calculations	Derived/expensive values
useCallback	Cache function references	Passing stable callbacks
Context API	Share small global data	Small/medium apps
Redux/Zustand	Manage app-wide state efficiently	Medium‚Äìlarge apps


React Query ‚Äî> alias TanStack Query 
- A React library which handles fetching more efficiently
- Handles caching and cache invalidation behind the scenes automatically. 
- Handles refetching via ‚ÄúreFetchOnWindowFocus: true‚Äù
- useInfiniteQuery() ‚Äî>  for infinite scrolling data. 
- Optimistic Updates 
Other Info ‚Äî> 
Global State ‚Äî> to avoid prop drilling to multiple levels, we can make a global state using Context API or Redux. 
Key Prop ‚Äî> every item in the list should have a unique identifier named key. So that React knows exactly which element is to be updated, removed or whatever. 
Event Handling ‚Äî> directly reference the function inline inside the curly braces with camelCase event name. Like onClick={handleClick}, onSubmit{handleSubmit}, onChange{handleChange} etc. 
Conditional rendering ‚Äî> using Tertary operator, && or || 
Curly Braces ‚Äî> We can add dynamic JS variables, functions etc in JSX but only inside curly braces. So, everything dynamic Js would go under curly braces. Like {variable}, {function}. 
	Double curly braces vs Single curly braces !!?? 
flushSync(){ () => setState(c => c+1)} ‚Äî> forces the component to render immediately after the update and not batch the updates. 


