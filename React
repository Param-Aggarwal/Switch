React Todo --> 
    1. Table 
    2. Form
    3. Hooks
    4. Debouncing, Throttling
    5. Fetch api calls, 
    6. Tailwind
    7. Lifecycle of hook

React is library to manage SPA. 
One Way data binding. 

# React Rendering —> 
- React makes copy of real DOM called VIRTUAL DOM, makes changes to that first as it is less expensive and fast, identifies difference with respect to Real DOM, and then applies only the reqd changes to REAL DOM. 
- By default, Reacts performs Client Side Rendering only. SSR can also be implemented fro particular case but not as easy as other library like Next.js. (in backend code, call for app component has to be made, then on frontend, that rendered server side component has to be hydrated with js on frontend)
- In React, functions and variables declared inside a component body are re-created on every render. This includes:
    * Arrow functions (const handleClick = () => {})
    * Objects (const obj = {})
- This is why hooks like useCallback and useMemo exist: to preserve reference identity between renders when needed.

## Client Side Rendering —> 
- All the bundled code(in form of HTML, CSS, JS files) is sent to client, and rendering of the web components happen in the client side only. Painting of the Dom happens at the client side only. 
- Processing for creation of Html elements from js happens at the client side, whenever the call is made for the website. 

## Server Side Rendering —>  
- The bundled code (HTML, CSS) is processed on the server side beforehand and stored in cache/DNS and is sent to the client as is. This reduces initial loading time on the client and increases UX. 
- Here, React app is also sent to the client(in form of HTML, CSS, JS) in the background. 
- And after the initial rendering of the pre-loaded HTML/CSS, whole react component renders again in the client, and JS is hydrated to the elements in runtime. 
- This re-rendering does not change any pre-loaded HTML elements(because the code is same before and after). Thus, the JS part is attached to the elements at the runtime so smoothly, that the client does not feel any change in UI. And hence does not degrade UX. 
- Note: Whole React APP is rendered again on the client but it feels like that only JS is attached at the client side because the initial loaded HTML, CSS is same afterwards also. 

## Hydration Failure —> 
- Sometimes, there occurs a difference between pre-loaded HTML, CSS components and re-rendered HTML, CSS, JS components. 
- This may occur due to some change in HTML while attaching JS. This may result in error in the UI. This is called Hydration Failure. 

Static Site Generation —> 
- Here, During the bundling of the code, whole component is pre-rendered along with HTML, CSS, JS and stored as cache/DNS. Here, website is compiled and run at the build time only. 
- And the static site is served to the client with pre-loaded JS. All the functionality works fine. And no re-rendering of the website takes place in the background. 
- This increase the performance significantly as server/client does not need to render every page dynamically for every request. 

## Incremental Site Generation —> 
-  Whenever any new data is added, then that data is added to the static site in the incremental fashion so as to not loose the advantage of SSG. 
- Incremental static site generation, aka incremental static regeneration (ISR), is a pattern added to static site generation that allows updating of existing pages and adding new ones, by pre-rendering a subset of pages in the background even while receiving new requests for pages.
- Flow is something like: 
    * During the initial site build, Next.js (often used with ISR) pre-renders static pages using getStaticProps. This means HTML is generated for these pages based on the available data at build time. 
    * You configure a revalidate time for each page. This tells Next.js how often to check for updates. For example, revalidate: 60 means it checks for updates every 60 seconds. 
    * When a user visits a page after its revalidation period has passed, the page will still serve the cached, static version initially. 
    * Background Regeneration: Next.js then triggers a regeneration of that page in the background. It fetches the latest data and rebuilds the HTML. 
    * Cache Update: Once the page is successfully regenerated, the cache is updated with the new version. 
    * Subsequent Requests: Subsequent requests to that page will then serve the updated, cached version, ensuring that users see the latest content. 
    * On-Demand Revalidation: If you need to update content immediately, you can use on-demand revalidation to trigger a page regeneration outside the scheduled revalidation time. 
## Hot Module Reloading —>
- Fdvgv


# URL based Routing —> 

# Components —> 
- Lifecycle of Component —> Mounting, Updating, Unmounting 
Controlled Components —> 
- We change components based on the change in state which is controlling that component
Pure and Impure Components —> 
Strict Component —> 
- wrapped around App Component to help us be safer and prevent errors. 
Portal Component —> 
- used when Particular component is to be loaded at specific place under specific component every time. 
Suspense component—> 
- used as fallback when data takes time to load. 

# Intro --> 
React -->  is the library only for defining React Components, React Elements and Component instances. Also, provides the diffing algo.
React Element -->  JS Object with properties such as: keys, props, type, <component-name>  etc. 
Reconciliation --> 
    - Generating of React element Tree in form of plain js objects. DOM Tree is basically a js object with multiple nested component objects. 
Virtual DOM vs Real DOM
React Renderer --> 
    - Generates DOM Tree from these elements and components and not React itself. React can be rendered differently for web, mobile etc. 
    - So, react is not web specific or mobile specific. It is generic and Renderer differenties its implementaiton on different environments. 
    - We can slso create our own React Renderer for custom implmenetation of React. 
JSX —> JS with XML , dynamic rendering possible with JSX opposite to HTML Static rendering. 
Props —> 
    - Used to pass properties onto child component. 
    - It is an Object. 
    - Can pass anything inside props, be it variables, functions, components(child components) etc. 
    - Has problem of Prop Drilling.  
State —> to manage data 
Keys --> 
    - Index should not be used as a key because diffing also see the changes based on keys and when index changes, keys changes and hence updates the whole component altogether which is very inefiicient. 

# React Fiber 
    - plain old js with some objects and properties 
    - Async ~~library~~ which focuses on animations and responsiveness 
    - It is a new reconciler came in React v15. Old Reconciler was Stack(sync, implmeemntaiton: stack). 
    - Fiber is generated fom React Element itself. 
    - Fiber Properties -> tag(defines 1-1 relationship with element), child, sibling, return, alternate etc. 
    - Fiber Tree is created from React Elements and then is executed smartly which increases performance
    - Smartly means Fiber breaks work into smaller chunks and schedules them according to their priority. fiber can do this becasue of time Slicing ability in Fiber which React did not have. 
    - Works in 2 phases: 
        - Render Phase --> 
            - Determines which nodes to be inserted, updated, deleted + which components needs lifecylce methods called. 
            - All of this info is stored in EFFECT List   
            - beginWork() --> going down the tree , completeWork() --> moving up the tree
        - Commit Phase --> 
            - All the changes done to copy tree and then reference of actual tree is swapped with copy tree to relect changes in UI.  
            - commitWork() 
    - Usages / Applications: 
        - Error Boundaries
        - Suspense and concurrent Mode
    


# Hooks —> 
- Hooks are functions which allows us to hook and manage states. 
- Lets us add state and other features to our functional components without using class based components. 
- GPT Link for Hooks: https://chatgpt.com/c/683c5e61-ccdc-8001-b424-70e94cc4955b (In Depth analysis)
- Link for below video: https://www.youtube.com/watch?v=LOH1l-MP_9k (Summarising all the hooks with their functionalities)
- ￼

State Hooks —> 
- useState —> to manage simple state management
- useReducer —> to handle complex or multiple dependent states with a single reducer function.
    * Helpful as it makes changes to all the related states in a single hook. 
    * Takes input —>  useReducer hook takes 2 inputs: Reducer function and initial states object
    * Outputs —> state object + dispatch function which changes the state based on actions. This function (dispatch) is called whenever this hook is triggered. 

Effect Hooks —> 
Used for dealing with external systems or doing things cannot be done by any other hook. * React schedules effects after painting to the screen**, not during render.

- useEffect —> 
    * Is asynchronous in nature
    * used to perform side effects 
    * Generally used for following two types of Side effects: 
        1. Event based —> click, submit, etc  —> But this should be handled by event Listeners itself and not useEffect
        2. Render Based —> fetch data from external system —> this should be handled by React Query or Next.js Iibrary. 
    * SHOULD NOT BE USED OFTEN. 
    * Actual USE CASE of useEffect is to sync React components with Browser APIs. 
    * For eg: when we want to sync video element of html with some variables. i.e. handle DOM elements with variables/states.
    * For eg: if isPlaying == true, then instruct the video element to play, otherwise stop. 
- useLayoutEffect —> 
    * stricter version of use Effect. 
    * Runs before rendering the page for the first time. -->  After DOM mutations but before paint
    * Is synchronous. Helpful in getting details from browser at runtime and then using them to load data. 
    * Use Case: find out client layout measurement and setting them in state even before rendering. 
- useInsertionEffect —> 
    * Runs before the above two. Even before rendering the ui. 
    * Is synchronous. 
    * To add styles to a particular js elements. 


Context Hooks —> 
- useContext —> Instead of prop Drilling, we use this hook to provide global context to our parent component and then can use it anywhere inside the child component even if it is 3-4-5 levels deep. 
    * How to implement —> 
        * Create context variable or object with the context values. (Can be defined in separate file named Context.js)
        * Wrap your parent component with Context.provider component. 
        * Pass value of context inside ContextProvider component as props. 
        * Use that value in child component with useContext Hook and the above made context variable as input. 
    * Directory Structure can be —> 
        * ￼
    * All components using useContext re-render when context value changes
    * Ca be used in combination with useState or useReducer hook. 
    * Use Case —> helps in enabling features like: (Basically global setting that do not change much)
        * Theme Switching
        * Authentication Context
        * Language Settings etc. 


Ref hooks —> 
- useRef —> 
    * It is similar to useState but keeps the state data across multiple re-renders. 
    * And also does not re render a page when state changes. 
    * It takes input the initial value of state similar to useState hook. 
    * It Outputs only the state data object, not a function (like SetData). because data is mutable itself. 
    * It has .current property which is used to change the values of data. 
    * Also have ref attribute to set value of data. Generally used to store DOM elements. 
    * Perfect for storing values like DOM elements, timers, or any mutable object that doesn’t need to trigger UI changes.
- useImperativeHandle —> 
    * Similar to ref hook but used when we want to pass the ref to child component. 
    * Needs ForwardRef function. 
    * Not used much
    * Implementation: 
        * make the ref
        * pass that as a prop to child component
        * wrap the child function inside forwardRef() function
Performance Hooks —> 
- useMemo —> implements memoisation to increase speed and avoid unnecessary calculations. 
    * It is used whenever we want to store value when something changes, For Eg: if numbers array change, the only calculate sum. 
    * i.e. Runs during a re-render. But does not cause a re-render itself. 
    * It always returns an output with some value. 
    * So the value of that sum can be assigned to any variable which may or may not be managed by any other hook
    * Conclusion —> Whenever the component re-renders (due to any state/prop change), useMemo() checks if its dependencies changed.
        * If yes → it recomputes the value.
        * If no → it returns the cached value from the last render.
- useCallback —> similar to useMemo but for functions instead of variables or objects. It Caches functions between renders. 
    - Does not trigger re-render. Runs during re-render only if dependency is changed. 
    - It basically maintains the identity of function at the time of re-rendering if the dependency is not changed in that re-rendering. 
    - Use it when function identity really matters — especially with:
        * React.memo
        * custom hooks
        * props optimisation
        * On useEffect Dependencies
    - Don’t —> If you're not passing the function as a prop or not depending on it in useEffect/useMemo, you probably don’t need useCallback. 

Transition Hooks —> 
- useTransition —> used when we need to run non-urgent state updates in background with low priority   so that urgent ones perform first. It Keeps UI Responsive while doing heavy updates in background. 
    * It does not make our code faster or it does not cancel the execution of the function. 
    * It just cancels the execution for previous state change 1 if a new state change 2 is received which has more priority. 
    * So the flow is like: 
        * change1 initiated —> 
        * handleChange1() is called with low priority set —> 
        * change2 initiated before completion of handleChange1() —> 
        * then handleChange2() is started and handleChange1() is abandoned. 
    * Helps in laggy UI scenarios 
    * Use Cases —> 
        * Large list filtering —> Don't freeze input while filtering 
        * Tab switching in dashboards —> Load new tab content in background
        * Search-as-you-type —> Let user type freely while searching
        * Form suggestions/autocomplete —> Defer API-heavy suggestions
        * Rendering charts/graphs —> Render Ul-heavy components non-urgently
- useDefferedValue —> 
    * instead of running in background, it defers the execution of the function upto some time(adaptive time delay by React only) and runs back the fn when it is free to do so. 
    * So the flow is like: 
        * change1 initiated —> 
        * handleChange1() is not called but deffered for some time—> 
        * change2 initiated before starting of handleChange1() —> 
        * then handleChange2() is started and handleChange1() is dropped. 
    * Also helps in laggy UI scenarios 
    * Can use useDeferredValue with React.memo() or useMemo() to optimise rendering of components that use the deferred value.
    * It Doesn't delay the state itself —> Only the value passed to the next component is delayed
    * Use Cases —> 
        * Filtering/search —>Don’t block input while showing results
        * Large lists —> Avoid re-rendering whole list too often
        * Dependent drop-downs —> Prevent UI freezing when one state triggers heavy work

- 🧠 Final Difference Recap:
    * useTransition → Runs the expensive update in the background with low priority → If a new high-priority update comes (e.g., user types again), → The previous low-priority update may be abandoned, and the new one starts
    * useDeferredValue → Delays the propagation of the input (query) to the expensive function → If input changes quickly again, it may skip earlier values → Only latest deferred value is eventually used → The expensive function is never called for intermediate values
* 
Extra hooks —> 
- useId —> Think of useId() as a layout helper, not a data identifier.
    * for generating random id’s for html attributes labelling. 
    * Can’t be used for object id’s when listing elements. \
* Not used in below scenarios: 
    * If you're styling with CSS using IDs (not recommended anyway).
    * If you're building only one instance of the form and are okay hardcoding static IDs.
    * If you don’t need label-input linking (e.g., placeholder-based UI).
- useDebugValue —> 
    * only used when using react debug tools in order for debugging. 


React 19 Hooks —> 
- Don’t need to use useMemo and useCallback hooks as compiler itself does the optimisation. 
- Don’t need ForwardRef at all. React compiler does this automatically. 
- use —> 
    * Lets u load resources asynchronously
    * Can resolve promises as well as read contexts. 
    * Replaces useEffect for rendering and useContext for reading context completely.
    * Instead of useEffect, we make fetch call inside use() hook with no dependency array. Also, provides functionality of Suspense component for acting as a fallback while loading the data in the background. Just wrap the component with Suspense component with fallback attribute and inside that your jsx. 
    * Instead of useContext(), just use use() completely. basically a name change, u can assume. 
    * Directives —> 
        * helps specify where to run the code (client or server)
        * implementation: “use client” or “use server” at the top of function/component file. 
- useOptimisitic() —> 
- useID() —> Think of useId() as a layout helper, not a data identifier.














# React Query —> alias TanStack Query 
- A React library which handles fetching more efficiently
- Handles caching and cache invalidation behind the scenes automatically. 
- Handles refetching via “reFetchOnWindowFocus: true”
- useInfiniteQuery() —>  for infinite scrolling data. 
- Optimistic Updates 

# Other Info —> 
Global State —> to avoid prop drilling to multiple levels, we can make a global state using Context API or Redux. 
Key Prop —> every item in the list should have a unique identifier named key. So that React knows exactly which element is to be updated, removed or whatever. 
Event Handling —> directly reference the function inline inside the curly braces with camelCase event name. Like onClick={handleClick}, onSubmit{handleSubmit}, onChange{handleChange} etc. 
Conditional rendering —> using Tertary operator, && or || 
Curly Braces —> We can add dynamic JS variables, functions etc in JSX but only inside curly braces. So, everything dynamic Js would go under curly braces. Like {variable}, {function}. 
	Double curly braces vs Single curly braces !!?? 




Dispatch fn
Lifecycle Methods