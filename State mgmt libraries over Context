React topic


âœ… Your Understanding	          ðŸ’¡ Clarification / Confirmation
Context API is great for small to medium data-sharing cases	                                          âœ… Correct â€” things like theme, language, auth state, or feature flags
For complex or deeply nested state (e.g., cart, analytics, dashboard data)â†’ Context becomes messy	    âœ… True â€” leads to prop-drilling or over-re-renders
  Re-renders in small trees can be optimized via React.memo / useMemo / useCallback	                  âœ… Yes â€” acceptable in low-scale apps
But for large apps, you need selectors and middleware for efficiency	                                âœ… Correct â€” Redux/Zustand use selectors so only the consuming components re-render
Context has no persistence (state lost on refresh)	                                                  âœ… Correct â€” must manually sync to storage
Libraries like Redux / Zustand solve this + add async handling, logging, and devtools	                âœ… Exactly right
Practical rule: Use Context for small, global UI-level data. 
Use state management library for app-level domain data.	                                              âœ… Spot-on best practice




Context api is good and helps in sharding the data between multiple components but only in cases where we have samll no of components. or data flow is simple 
i.e parent too child to gradparent and not too complex. in small cases, re-rendering can be handled easily by either using React.memo or useMemo or useCallback
and even after this, if rendering is happening, this is acceptable as not much no of components are being re-rendered. But if my applicaitn has 10's-20s of compoents, 
and have very complex logic of data sharing, then using context becomes repititive and reduces efficency. Also, it accompanies other problems like data not 
stored permanently (if we rfresh the page, data is lost i.e. no persistence). whereas if we use state management libraries which can efficently pass data between
the whole react app, we also get additional features like data persistence, selector based rendering of components, async flow is also handled easily etc. so, 
for complex data sharing, it is preferred to use state mgmt libraries. but for smaller use cases like: session storage maintenance, theme of site, language 
selected by user, context can be used, but some complex data like cart updation, user details, dashoards etc can be shared thoru all app via State mngmt libraries.

Cons of Context API
- Causes re-renders of all the components using the context if context changes. even if only the reference changes and no actual value is changed. 
- This can be overcome with hooks like useMemo(), React.memo(), useCallback() etc but this can become messy if large app is supported with large no of components. 
- Also, no data persistency is guranteed in context.  
- Debugging is difficult in context as we cannot tracj what caused the re-render. becaue context does not log that info. 
- Handling async flow via Context API is alo difficult. 

React.memo()   --> prevents re-renders of the functional component when the props passed have not been changed. React.memo is a higher-order component (HOC) that memoizes a functional component.
                    Con is that react.memo memoises only for props change and not global state/context changes. i.e even if context value remains same but reference to context's value object is changed, 
                    component is being re-rendered. 
âœ… Use when:
- Component is pure (renders same UI for same props).
- Itâ€™s re-rendered frequently with unchanged props.
- Itâ€™s performance-sensitive (heavy DOM or complex UI).
- Child depends only on props (no internal state or context).
âŒ Donâ€™t use when:
- Component is very lightweight â†’ memo adds overhead.
- Props change often â†’ memo comparison becomes wasted work.
- Component relies on context or global state (still re-renders).
- Child re-renders are cheap or infrequent.

useCallback()  --> Unnecessary re-renders of children just because the parent created a new function reference. useCallback() memoizes a function reference between renders â€”
                    so the same function instance is reused until its dependencies change. useCallback(fn,[])
useMemo()      --> Ii is similar in spirit but used for values/computations instead of functions. useMemo(() => fn, [])
Cons of using them: both increase code complexity slightly and add memory overhead. 
âœ… Use them only when:
- The value/function is expensive to compute/create
- Youâ€™re passing props to memoized children

Note: useCallback() and React.memo() work best together. If a function in a component is not memoised with useCallback, then on refreshing the component, it will re-render 
because reference to that function will change. Hence component memoised with React.memo() will still not be re-rendered. 
See example below: 
const handleClick = useCallback(() => { console.log("clicked"); }, []);
const Child = React.memo(({ onClick }) => {
  console.log("child rendered");
  return <button onClick={onClick}>Click</button>;
});
Note: Without useCallback, the new handleClick reference would break memoization.

-------------------------- State mgmt libraries like redux, zustand, redux toolkit etc. ----------------------

Redux is state management library which helps to manage the global state of our React app and can be used by any component of our application. It is synchronous 
in nature i.e. it can only handle synchronous actions like: { type: "INCREMENT" } etc. For async operaitons, we use middlewares. (discussed later)

Redux is based on:
1. Single source of truth               â†’ One store for the whole app.
2. State is read-only                   â†’ You cannot modify state directly; only via actions. Instead of mutating, we return a new copy of the state using spread operators. 
3. Changes made with pure fn(reducers)  â†’ Reducers describe how state changes

Redux: 
- Store      --> that holds all the states and data of the application
- Action     --> different methods supported to the user to mutate the items in store.
- Reducer    --> describes how the state will change when action is called. (takes state and actions, and outputs, new state), is a pure function

React Redux:
- useSelector   --> hook to selectively read data from the store. Component depends on only that part of store for re-rendering. 
- useDispatch   --> hook which allows to send actions to the store via dispatch method. Dispatch describes how the action is being called
- Provider      --> wraps the whole react app and makes the Redux store available to every component inside it.

Limitations of Redux: 
- Too much boilerplate
- hard to handle async tasks
- Manual setup for actions, reducers, constants.
- dev tools not helpful in time travel by replaying state snapshots.

Redux Dev Tools: 
Redux provides excellent debugging support through Redux DevTools, which allows me to inspect every state change in real time. 
I can see which action was dispatched, its payload, and how it changed the previous state to the next state. This makes debugging 
far easier than Context API, where Iâ€™d have to rely on manual logs. Redux also enforces immutability, so I can even â€˜time-travelâ€™ 
between states â€” something not possible with Context.â€
ðŸ’¡ So yes â€” Reduxâ€™s centralized state + DevTools integration = much easier debugging, tracking, and rollback.

Middlewares: 
Why do we need this: 
- React can only perform sync operations like {type: "Increment"}. because reducers are pure functions i.e. no async operations. So,
  It cannot handle async calls like: API Calls, delaying actions, logging them, handling complex logic etc. So, for this we have a concept of middleware. 

What is Middleware !? 
- It is basically a function which sits between dispatching the action and receiving at the reducer. 
Without middleware, the flow is : ----> Component â†’ dispatch(action) â†’ Reducer â†’ Store updates state
With middleware, the flow is: ------> Component â†’ dispatch(action) â†’ Middleware(s) â†’ Reducer â†’ Store updates state

What do Middleware do ?
- Middleware helps perform side effects outside reducers, and then dispatch plain actions when ready.
- Log, modify, delay, or stop an action before it hits the reducer.
- Trigger side effects (like API calls).
- Dispatch additional actions automatically.

Pros of Middleware: 
- Async Support: 	          Enables async workflows (API calls, timers, etc).
- Centralized Side Effects:	Keeps reducers pure and focused only on state changes.
- Enhanced Debugging:     	Middlewares like redux-logger show exact action and state flow.
- Reusability:              You can plug multiple middlewares (e.g., thunk, saga, logger).
- Clean Code:              	Reduces repetitive logic inside components (no need for manual loading/error states everywhere).

Redux Thunk: 
So, Redux Thunk is a middleware that Redux provides for supporting async tasks execution. It basically intercepts every action before it reaches reducers. 
In One line: Redux Thunk is a middleware that checks if an action is a function, and if so, executes it with dispatch and getState, 
enabling async and conditional logic inside Redux.

Internal implementation of Redux thunk: 
const thunkMiddleware = ({ dispatch, getState }) => next => action => {
  if (typeof action === 'function') {
    // If action is a function (thunk), call it with dispatch & getState
    return action(dispatch, getState);
  }
  // Otherwise, pass it to the next middleware or reducer
  return next(action);
};


Q) How do we pass data from child to parent !!
Ans) Make state in parent and pass callback func to update state to the child as prop. 

Lifecycle Methods:
React lifecycle methods are special hooks (in classes or functions) that let you perform side effects during specific points of a 
componentâ€™s existence â€” like mounting, updating, or unmounting.
Mounting    --> On first render, componentDidMount(), useEffect(() => {...}, []),	Data fetch, init
Updating    -->	On prop/state change, componentDidUpdate(), useEffect(() => {...}, [deps]), React to change
Unmounting	--> Before removal, ComponentWillUnmount(),	useEffect cleanup, Cleanup timers/listeners

Hooks: 
- Hooks are the functions that lets us use state, lifecycle methods, contexts inside functional components. Earlier, functional components
  were just stateless UI renderers and we had to use class-based components to control the state. But now, with the help of hooks, functional components
  can be used to manage states of component, therefore making the components more re-usable and easy to manage. 
State: 
- States are variables that persist across re-renders. So, we declare state only when we need the values across re-renders. Otherwise, 
  normal variable can serve the purpose. 
- State is immutable
- State updates are async
- Using state inside useEffect iwth no dependency can cause unlimited re-renders. 
useEffect: 
  - No dependency array       --> after every render  (for debugging/logging)
  - Empty []                  --> on first mount (for api calls, event listeners)
  - [dep]                     --> when state mentioned in dep change (for updating components when state changes)
  - cleanup                   --> before un-mount (for removing event listeneres, timers) 
- useEffect runs twice in dev mode (mount --> unmount --> mount) for ensuring resilient UI and keeping it cleanup safe. 
- Note: Donâ€™t mutate state directly inside useEffect (causes infinite loops).
- Dependecies can have any reactive value that can change i.e states, props, contexts, memoised functions, derived props/states, etc.
- useMemo and useCallback should be used in accordance with useEffect hook to increase the performance of the website and reduce the unnecessary re-renders.
- Can do sync and sync taks both in it. But cannot make the effect callback async directly. Like: useEffect(async () => {...}, []);  
  Correct approach is written below: 
    useEffect(() => {
      const fetchData = async () => {
        const res = await fetch("/api");
      };
      fetchData();
    }, []);
useLayoutEffect
- runs synchronously during th render process. It runs before the browser paints but after the Real DOM Updation.
- As it blocks the paint, it cna be a performance overhead if used extensively. 
Flow of render --->     Component runs --> React builds the Virtual DOM --> updates the real DOM --> useLayoutEffect runs 
                              --> Paint the browser with updated DOM --> useEffect runs
- Use Cases: 
  - Measure element size before paint
  - Scroll to a position before user sees it
  - Trigger synchronous animations (GSAP, Framer Motion)
  - Prevent flicker in layout shift-sensitive UIs
Note: During SSR, DOM cannot be manipulated. So, useEfect and useLayoutEffect cannot manipulate DOM on server. Therefore, does nothing. 
useRef
- persists data between re-renders without causing re-renders. 
- Used to store mutable values acroos re-renders without initiating re-render itself. Eg: timers, DOM nodes, cache, prev values
