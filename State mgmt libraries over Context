-------------------state management and Data Sharing in React ---------------


‚úÖ Your Understanding	                                                                                üí° Clarification / Confirmation
Context API is great for small to medium data-sharing cases	                                          ‚úÖ Correct ‚Äî things like theme, language, auth state, or feature flags
For complex or deeply nested state (e.g., cart, analytics, dashboard data)‚Üí Context becomes messy	    ‚úÖ True ‚Äî leads to prop-drilling or over-re-renders
  Re-renders in small trees can be optimized via React.memo / useMemo / useCallback	                  ‚úÖ Yes ‚Äî acceptable in low-scale apps
But for large apps, you need selectors and middleware for efficiency	                                ‚úÖ Correct ‚Äî Redux/Zustand use selectors so only the consuming components re-render
Context has no persistence (state lost on refresh)	                                                  ‚úÖ Correct ‚Äî must manually sync to storage
Libraries like Redux / Zustand solve this + add async handling, logging, and devtools	                ‚úÖ Exactly right
Practical rule: Use Context for small, global UI-level data. 
Use state management library for app-level domain data.	                                              ‚úÖ Spot-on best practice

Context API: 
Context api is good and helps in sharding the data between multiple components but only in cases where we have samll no of components. or data flow is simple 
i.e parent too child to gradparent and not too complex. in small cases, re-rendering can be handled easily by either using React.memo or useMemo or useCallback
and even after this, if rendering is happening, this is acceptable as not much no of components are being re-rendered. But if my applicaitn has 10's-20s of compoents, 
and have very complex logic of data sharing, then using context becomes repititive and reduces efficency. Also, it accompanies other problems like data not 
stored permanently (if we rfresh the page, data is lost i.e. no persistence). whereas if we use state management libraries which can efficently pass data between
the whole react app, we also get additional features like data persistence, selector based rendering of components, async flow is also handled easily etc. so, 
for complex data sharing, it is preferred to use state mgmt libraries. but for smaller use cases like: session storage maintenance, theme of site, language 
selected by user, context can be used, but some complex data like cart updation, user details, dashoards etc can be shared thoru all app via State mngmt libraries.

Cons of Context API
- Causes re-renders of all the components using the context if context changes. even if only the reference changes and no actual value is changed. 
- This can be overcome with hooks like useMemo(), React.memo(), useCallback() etc but this can become messy if large app is supported with large no of components. 
- Also, no data persistency is guranteed in context.  
- Debugging is difficult in context as we cannot tracj what caused the re-render. becaue context does not log that info. 
- Handling async flow via Context API is alo difficult. 

------- Optimisation Techniques   
- React.memo()   --> prevents re-renders of the functional component when the props passed have not been changed. React.memo is a higher-order component (HOC) that memoizes a functional component.
                      Con is that react.memo memoises only for props change and not global state/context changes. i.e even if context value remains same but reference to context's value object is changed, 
                      component is being re-rendered. 
  ‚úÖ Use when:
  - Component is pure (renders same UI for same props).
  - It‚Äôs re-rendered frequently with unchanged props.
  - It‚Äôs performance-sensitive (heavy DOM or complex UI).
  - Child depends only on props (no internal state or context).
  ‚ùå Don‚Äôt use when:
  - Component is very lightweight ‚Üí memo adds overhead.
  - Props change often ‚Üí memo comparison becomes wasted work.
  - Component relies on context or global state (still re-renders).
  - Child re-renders are cheap or infrequent.

- useCallback()  --> Unnecessary re-renders of children just because the parent created a new function reference. useCallback() memoizes a function reference between renders ‚Äî
                    so the same function instance is reused until its dependencies change. useCallback(fn,[])
- useMemo()      --> Ii is similar in spirit but used for values/computations instead of functions. useMemo(() => fn, [])
Cons of using them: both increase code complexity slightly and add memory overhead. 
‚úÖ Use them only when:
- The value/function is expensive to compute/create
- You‚Äôre passing props to memoized children

Note: useCallback() and React.memo() work best together. If a function in a component is not memoised with useCallback, then on refreshing the component, it will re-render 
because reference to that function will change. Hence component memoised with React.memo() will still not be re-rendered. 
See example below: 
const handleClick = useCallback(() => { console.log("clicked"); }, []);
const Child = React.memo(({ onClick }) => {
  console.log("child rendered");
  return <button onClick={onClick}>Click</button>;
});
Note: Without useCallback, the new handleClick reference would break memoization.

useTransition
- Hook which lets mark some state updates as non urgent and React can defer them while performing heavy re-renders. 
- It just tells React's scheduler: ‚ÄúThis update is low priority ‚Äî do it after urgent work is finished.‚Äù
  const [isPending,startTransition] = useTransition();
useDefferedValue 
- Similar to useTransition but for derived value rather than states.
Suspense
- Component which is used to pause rendering until something (like data or code) is ready.
- It shows a fallback UI (like a spinner or skeleton) during the wait. 
Lazy Loading
- React.lazy() delays the rendering of the component/function unless required. And shows the fallback UI until then via Suspense Hook. 
- Wrap the whole component inside React.lazy() function. 
Code Splitting 
- Beaking your app‚Äôs JavaScript bundle into smaller chunks so the browser loads only what‚Äôs needed ‚Äî instead of one big file.
- It‚Äôs a performance optimization technique that improves initial load speed.

------- SEO Optimisation ------
- Helmet: React Library which helps in increasing SEO performance of the website by manipulating the <head> section of the html document. 
          Can be used in SSR as well as CSR both. 
  Eg: import { Helmet } from "react-helmet";
      function ProductPage({ product }) {
        return (
          <>
            <Helmet>
              <title>{product.name} | My Store</title>
              <meta name="description" content={product.description} />
            </Helmet>
            <h1>{product.name}</h1>
          </>
        );
      }

-------------------------- State mgmt libraries like redux, zustand, redux toolkit etc. ----------------------
Redux is state management library which helps to manage the global state of our React app and can be used by any component of our application. It is synchronous 
in nature i.e. it can only handle synchronous actions like: { type: "INCREMENT" } etc. For async operaitons, we use middlewares. (discussed later)
Redux is based on:
1. Single source of truth               ‚Üí One store for the whole app.
2. State is read-only                   ‚Üí You cannot modify state directly; only via actions. Instead of mutating, we return a new copy of the state using spread operators. 
3. Changes made with pure fn(reducers)  ‚Üí Reducers describe how state changes
Redux: 
- Store      --> that holds all the states and data of the application
- Action     --> different methods supported to the user to mutate the items in store.
- Reducer    --> describes how the state will change when action is called. (takes state and actions, and outputs, new state), is a pure function
React Redux:
- useSelector   --> hook to selectively read data from the store. Component depends on only that part of store for re-rendering. 
- useDispatch   --> hook which allows to send actions to the store via dispatch method. Dispatch describes how the action is being called
- Provider      --> wraps the whole react app and makes the Redux store available to every component inside it.
Limitations of Redux: 
- Too much boilerplate
- hard to handle async tasks
- Manual setup for actions, reducers, constants.
- dev tools not helpful in time travel by replaying state snapshots.
Redux Dev Tools: 
Redux provides excellent debugging support through Redux DevTools, which allows me to inspect every state change in real time. 
I can see which action was dispatched, its payload, and how it changed the previous state to the next state. This makes debugging 
far easier than Context API, where I‚Äôd have to rely on manual logs. Redux also enforces immutability, so I can even ‚Äòtime-travel‚Äô 
between states ‚Äî something not possible with Context.‚Äù
üí° So yes ‚Äî Redux‚Äôs centralized state + DevTools integration = much easier debugging, tracking, and rollback.
Middlewares: 
Why do we need this: 
- React can only perform sync operations like {type: "Increment"}. because reducers are pure functions i.e. no async operations. So,
  It cannot handle async calls like: API Calls, delaying actions, logging them, handling complex logic etc. So, for this we have a concept of middleware. 
What is Middleware !? 
- It is basically a function which sits between dispatching the action and receiving at the reducer. 
Without middleware, the flow is : ----> Component ‚Üí dispatch(action) ‚Üí Reducer ‚Üí Store updates state
With middleware, the flow is: ------> Component ‚Üí dispatch(action) ‚Üí Middleware(s) ‚Üí Reducer ‚Üí Store updates state
What do Middleware do ?
- Middleware helps perform side effects outside reducers, and then dispatch plain actions when ready.
- Log, modify, delay, or stop an action before it hits the reducer.
- Trigger side effects (like API calls).
- Dispatch additional actions automatically.
Pros of Middleware:
- Async Support: 	          Enables async workflows (API calls, timers, etc).
- Centralized Side Effects:	Keeps reducers pure and focused only on state changes.
- Enhanced Debugging:     	Middlewares like redux-logger show exact action and state flow.
- Reusability:              You can plug multiple middlewares (e.g., thunk, saga, logger).
- Clean Code:              	Reduces repetitive logic inside components (no need for manual loading/error states everywhere).
Redux Thunk: 
So, Redux Thunk is a middleware that Redux provides for supporting async tasks execution. It basically intercepts every action before it reaches reducers. 
In One line: Redux Thunk is a middleware that checks if an action is a function, and if so, executes it with dispatch and getState, 
enabling async and conditional logic inside Redux.
Internal implementation of Redux thunk: 
const thunkMiddleware = ({ dispatch, getState }) => next => action => {
  if (typeof action === 'function') {
    // If action is a function (thunk), call it with dispatch & getState
    return action(dispatch, getState);
  }
  // Otherwise, pass it to the next middleware or reducer
  return next(action);
};

---------- Q) How do we pass data from child to parent !!
Ans) Make state in parent and pass callback func to update state to the child as prop. 

----------------- Lifecycle Methods -------------------
React lifecycle methods are special hooks (in classes or functions) that let you perform side effects during specific points of a 
component‚Äôs existence ‚Äî like mounting, updating, or unmounting.
Mounting    --> On first render, componentDidMount(), useEffect(() => {...}, []),	Data fetch, init
Updating    -->	On prop/state change, componentDidUpdate(), useEffect(() => {...}, [deps]), React to change
Unmounting	--> Before removal, ComponentWillUnmount(),	useEffect cleanup, Cleanup timers/listeners

----------------- Hooks: --------------------
- Hooks are the functions that lets us use state, lifecycle methods, contexts inside functional components. Earlier, functional components
  were just stateless UI renderers and we had to use class-based components to control the state. But now, with the help of hooks, functional components
  can be used to manage states of component, therefore making the components more re-usable and easy to manage. 
State: 
- States are variables that persist across re-renders. So, we declare state only when we need the values across re-renders. Otherwise, 
  normal variable can serve the purpose. 
- State is immutable
- State updates are async
- Using state inside useEffect iwth no dependency can cause unlimited re-renders. 
useEffect: 
  - No dependency array       --> after every render  (for debugging/logging)
  - Empty []                  --> on first mount (for api calls, event listeners)
  - [dep]                     --> when state mentioned in dep change (for updating components when state changes)
  - cleanup                   --> before un-mount (for removing event listeneres, timers) 
- useEffect runs twice in dev mode (mount --> unmount --> mount) for ensuring resilient UI and keeping it cleanup safe. 
- Note: Don‚Äôt mutate state directly inside useEffect (causes infinite loops).
- Dependecies can have any reactive value that can change i.e states, props, contexts, memoised functions, derived props/states, etc.
- useMemo and useCallback should be used in accordance with useEffect hook to increase the performance of the website and reduce the unnecessary re-renders.
- Can do sync and sync taks both in it. But cannot make the effect callback async directly. Like: useEffect(async () => {...}, []);  
  Correct approach is written below: 
    useEffect(() => {
      const fetchData = async () => {
        const res = await fetch("/api");
      };
      fetchData();
    }, []);
useLayoutEffect
- runs synchronously during th render process. It runs before the browser paints but after the Real DOM Updation.
- As it blocks the paint, it cna be a performance overhead if used extensively. 
Flow of render --->     Component runs --> React builds the Virtual DOM --> updates the real DOM --> useLayoutEffect runs 
                              --> Paint the browser with updated DOM --> useEffect runs
- Use Cases: 
  - Measure element size before paint
  - Scroll to a position before user sees it
  - Trigger synchronous animations (GSAP, Framer Motion)
  - Prevent flicker in layout shift-sensitive UIs
Note: During SSR, DOM cannot be manipulated as there is no DOM on server. So, useEfect and useLayoutEffect do not run in SSR. Therefore, does nothing. 
useRef
- persists data between re-renders without causing re-renders. 
- Used to store mutable values acroos re-renders without initiating re-render itself. Eg: timers, DOM nodes, cache, prev values.
forwardRef (Not a hook)
- React does not allow the ref to be passed tochild as prop. These are handled specially in react. this can be done using forward Ref function. 
  Eg: 
    Ref declared in parent but passed to the child
    const Child = React.forwardRef((props, ref) => {
      return <input ref={ref} placeholder="Enter name" />;
    });
useReducer
- advanced version of useState hook to handle multiple state changes via a single state. For eg: form fields. 
- const [state,dispatch] = useReducer(reducer fn(), initialState)
- Very similar to redux --> using redicer function to mutate the state indirectly via dispatching actions. Just that useReducer is accessible 
                              within the component. Not sharable across the whole React application.
useDebugValue
- What: Add debug labels/info for custom hooks in React DevTools.
- Why: To understand hook state at a glance without console spam.
- How: useDebugValue(value) or useDebugValue(value, formatFn).
- Use cases: Auth hooks, network status hooks, data-fetching hooks in shared libraries.
- Gotchas: Dev-only. Not for rendering. Mostly for reusable hooks.
useImperativeHandle
- What: Expose custom methods from a child to parent through refs.
- Why: Parent sometimes needs to imperatively control child (focus, scroll, open/close).
- How: forwardRef + useImperativeHandle(ref, () => ({ ...publicAPI })).
- Use cases: Forms, modals, focus, scroll, video controls.
- Gotchas: Can make code less declarative if abused ‚Üí use only when DOM-like control is needed.

-------------- Error boundary ------------
- Component which handles error at the component level. whenever component rendering fails (due to invalid prop, render failure etc), 
  React looks if the parent component is error boundary or not and then goes up till it finds and if not, shows error otherwise Fallback UI. 
- Library react-error-boundary is used. 
- Component({error, resetErrorBoundary}) 
- Props: 
    - FallbackComponent={}, 
    - onError=()=>{}, 
    - onReset=()=>{}, 
    - resetKeys=[](used for auto resetting)


React Router and protected routes, broewser routes, 
How to pass data between different compoenents using ReactRouter (props.history.push, props.match.params)


---------------- Strict Mode ------------
- React.StrictMode is a development-only wrapper that activates additional checks and warnings for its descendants. 
- It helps detect side effects, deprecated APIs, and unsafe patterns, ensuring your components are pure and future-proof for concurrent rendering.
- It doesn‚Äôt affect production builds.
Note: By default, all components and hooks in React should be pure i.e. no side effects and always give the same output. 

----------- Flux ------------
- Flux is an architectural pattern introduced by Facebook for managing data flow in React applications.
- It enforces unidirectional data flow through actions, dispatcher, stores, and views ‚Äî making state predictable and debugging easier. 
- Redux is a simplified implementation of the Flux pattern.


----------- Higher Order component --------------


Custom Hooks vs HOC 
Custom Hooks ‚Üí 
- reuse logic only (stateful behavior, effects, data fetching).
- Each component decides its own UI using that logic.
- Great when the UI differs, but logic is shared.
- Example: useAuth(), useFetch(), useDebounce()

HOCs ‚Üí 
- reuse logic + structural pattern/UI behavior together.
- You wrap existing components to extend or modify their render behavior.
- Great when multiple components follow the same render structure or need to be conditionally wrapped (auth, theming, logging, etc.).

Summary: 
‚úÖ Use Custom Hooks ‚Üí when logic is shared but UI differs.
‚úÖ Use HOCs ‚Üí when both logic and component structure/layout are reused or wrapped.


-------------- Next.js -------------
SSR: 
- HTML is generated on the server at each request ‚Äî meaning every time a user hits the page, Next.js runs your code, fetches data, and sends a fresh HTML.
- getServersideProps is used. 
  Pros:  
      - Fresh HTML page is rendered every time. 
      - SEO friendly website
  Cons: 
      - Takes time to render the page
      - Requires server side processing - expensive at scale. 
      - Need caching for optimization. 
  Use Case: 
      - News, Product details
      - Admin dashboards with live data
      - Order tracking 
      - Sports score --> basically data that changes very frequently
SSG: 
- HTML is generated once at build time, not on every request.
- Next.js pre-renders all pages into static HTML files which are served instantly from CDN.
- getStaticProps is used. 
  Pros: 
    - Fastest load time (pre-rendered HTML served via CDN)
    - No Server Load at runtime. 
    - SEO friendly (fully rendered content).
  Cons:
    - Can only be used for static sites. Not for dynamic data.  
    - Outdated content unless rebuilt. 
    - larger build time for large applications. 
  Use Cases: 
    - Blogs, documentation sites.
    - Product pages with rarely changing info.
    - Marketing pages, portfolios, landing pages.
ISR: 
- A hybrid between SSR and SSG.
- Next.js builds static pages, but you can regenerate them periodically in the background using a revalidate timer.
- getStatisProps with revalidate flag is used. 
